## 资源
### 可重用资源和消耗性资源
- 可重用性资源
```
可重用性资源是一种可供用户重复使用多次的资源：
  <1> 每一个可重用性资源都只能分配给一个进程使用, 不允许多个进程共享
  <2> 进程在使用可重用性资源时, 须按照这样的顺序: 
      - 请求资源, 如果请求资源失败, 请求进程将会被阻塞或循环等待
      - 使用资源, 进程对资源进行操作, 如打印机进行打印
      - 释放资源, 当进程使用完后释放资源
  <3> 系统中每一种可重用资源都是固定个数的, 进程在运行期间既不能创建也不能删除它
```
- 可消耗性资源
```
可消耗性资源又称为临时性资源, 它是在进程运行期间, 由进程动态地创建和消耗的, 如生产者消费者案例中的
缓冲区, 以及进程间通信的消息等
```
## 可抢占性资源和不可抢占性资源 
- 可抢占性资源
```
进程在获取该资源后, 可以被其它进程或系统抢占, 如优先级高的进程可以抢占优先级低的进程的CPU, 对于这类
资源是不会产生死锁的
```

- 不可抢占性资源
```
一旦系统把某资源分配给该进程后, 就不能将其强行收回, 只能在进程用完后自行释放, 如打印机
```

## 死锁(对不可抢占资源以及可消耗资源进行争夺时引起的)
- 定义
```
一组进程中每一个进程都在等待另一个死锁进程所占有的资源, 或者说每个进程所等待的事件是该组中其它进程
释放所占有的资源, 但由于所有这些进程都已无法运行, 因此它们谁也不能释放资源, 致使没有任何一个进程可
被唤醒, 这样这组进程就只能无限期地等待下去
```
- 产生死锁的必要条件
```
<1> 互斥条件, 在一段时间内某资源只能被一个进程占用, 如果此时其它进程想要使用则必须进行等待, 直到该
    进程执行完毕主动释放资源
<2> 请求和保持条件, 进程保持了一些资源的同时去请求其他资源, 而其它资源同时被其它进程占用, 所以该进
    程就会进入阻塞状态, 并且不释放已经占有的资源
<3> 不可抢占条件, 进程持有的资源在进程不是主动释放的情况下不能被其它进程抢占
<4> 循环等待条件, 发生死锁时, 必然存在一个循环链, 比如进程A请求一个正在被进程B占用的资源x, 进程B请
    求一个正在被进程A占用的资源y, 则进程A和进程B都会因为请求的资源被占用而进入阻塞状态
```

## 处理死锁的方式
- 预防死锁
```
预防死锁通过破坏死锁产生的四个必要条件之一来达到死锁无法产生
<1> 破坏互斥条件, 一般来说破坏该条件的可行性不高, 甚至有时候无法破坏, 举个例子, 当我们在使用打印机
    的时候, 对于打印机这种临界资源, 一般是互斥访问的, 当一个进程请求打印机资源失败时则进入阻塞, 那
    么我们可以设置一个队列, 将所有申请打印机资源的进程放入该队列, 打印机依次对该队列的任务进行执行,
    则此时进程即使没有立马使用打印机, 但是却不会被阻塞, 因为放入了队列会让进程以为在执行打印机

<2> 破坏请求和保持条件, 方式一是进程一开始执行就立马获得所有在执行过程中的资源, 这样就不会产生死锁
    了, 而没有获取成功则进入阻塞, 方式二是进程在执行过程中需要该资源时采取申请, 而对于前面已经使用
    完成的资源必须立马释放

<3> 破坏不可抢占条件, 当一个进程持有了一些不可抢占的资源的同时, 如果其去申请其它的资源, 如果没有申
    请成功则释放自身拥有的所有不可抢占资源, 可行性不高, 因为释放资源就等于使得前一阶段的工作失效了,
    代价太大, 实现起来复杂

<4> 破坏循环等待条件, 通过对所有的资源进行线性排序并赋予不同的序号, 规定每隔进程必须按序号递增的顺
    序请求资源, 如果一个已经拥有了序号高的资源再去申请序号低的资源, 则其必须放弃已有的资源而重新申
    请, 这样一个进程只能申请后面的资源, 其后面的资源肯定是能够申请到的, 从而破坏了循环等待条件, 但
    是如何去规定这个资源的顺序就很重要了, 该方法也存在缺点, 就是当新增加一个设备的时候, 需要对顺序
    进行调整, 也会增加编程时的复杂度    
```
- 避免死锁
```
描述: 避免死锁同一是属于事先预防的策略, 不同于上面的预防策略的是, 上面的预防策略是去破坏死锁产生的
      条件,而避免死锁的方式是通过对进程申请资源时进行判断, 如果能找到一条安全序列则将资源分配给它,
      所以避免死锁的方式就是防止进程进入不安全状态, 确保系统始终处于安全状态

银行家算法基本思想: 每一个进程在进入系统时, 可能需要每种资源类型的最大单元数目, 其数目不应超过系统
                  所拥有的资源总量, 当进程请求一组资源时, 系统必须首先确定是否有足够的资源分配给
                  该进程, 如果没有则让进程等待, 如果有则进一步计算将这些资源在分配给进程之后是否
                  会使得系统处于不安全状态, 如果不会才分配资源给它, 否则进行等待

数据结构:
  <1> 可利用资源数组Available, 这是一个含有m个元素的数组, 其中每一个元素代表一类可利用的资源数目,
      其初始值是系统中所配置的该类全部可用资源的数目, 其数值会随着该类资源的分配和回收进行动态地改
      变, 如果Available[j] = k, 表示资源j地可用个数为k个
  <2> 最大需求矩阵Max, 这是一个n * m地矩阵, 它定义了系统中n个进程中地每隔进程对m类资源地最大需求,
      Max[i][j] = k表示第i个进程对第j个资源地最大需求为k个
  <3> 分配矩阵Allocation, 这也是一个n * m的矩阵, 它定义了系统中每一类资源当前已分配给每一进程的资
      源数, Allocation[i][j] = k表示分配给进程i的j类资源的个数为k个
  <4> 需求矩阵Need, 这也是一个n * m的矩阵, 用以表示每一个进程尚需的各类资源数, 如果Need[i][j] = k
      则表示进程i需要的j类资源的个数为k     

银行家算法:
  设Request数组是进程P的当时的请求数组, 即Request[j] = k表示进程P请求j类资源的个数为k个, 当进程P
  发出了资源请求后, 系统会按照下面的步骤进行检测:
    <1> 如果Request[j] <= Need[p][j], 则转向下一步, 否则报错, 因为其此时申请的资源j的个数大于了
        其一开始就确定的个数
    <2> 如果Request[j] <= Available[j], 则执行下一步, 否则进程阻塞等待, 因为其申请的资源的个数大
        于了系统此时拥有的资源j的个数
    <3> 系统尝试将资源分配给进程P, 则需要暂时的修改数据结构中的数值:
        Available[j] = Available[j] - Request[j];
        Allocation[p][j] = Allocation[p][j] + Request[j];
        Need[p][j] = Need[p][j] - Request[j];
    <4> 执行安全性算法, 检查此次资源分配系统是否处于安全状态, 如果处于安全状态, 则正式分配资源给该
        进程, 如果不安全, 则恢复原来的资源状态, 进程进入阻塞状态

安全性算法:
    <1> 设置两个数组, 一个是curAvailable, curAvailable[j] = k表示当前第j个资源的可用资源个数为k
        个, 一开始的时候curAvailable = Availablle, 另一个数组是Finish数组, Finish[i] = true表
        示当前系统能够分配足够的资源给进程i以支持进程继续推进下去直到完成, 初始的时候均为false
    <2> 从进程集合中找到一个Finish[i] = false并且Need[i][j] <= curAvailable[j]的进程, 如果找到
        则执行下一步, 找到一个进程说明该进程需要的需要的资源系统能够满足其运行下去
    <3> 假设当进程i运行获得资源后, 可顺利执行, 直至完成, 并释放处分配的所有资源, 之后执行:
        curAvailable[j] = curAvailable[j] + Allocation[i][j];
        Finish[i] = true;
        之后继续从第二步开始执行
    <4> 如果所有进程的Finish[i] = true, 则表示经过这样的尝试分配, 能找到一条安全序列, 系统在分配
        后是处于安全状态的
```

- 检测死锁
```
资源分配图: 对于下面的资源分配图, r1和r2表示资源类型, 方框里面的圆圈个数表示资源的个数, p1和p2表示
           两个进程, 每一个从进程指向资源的箭头表示进程此时正在请求该类资源的个数为1, 一个箭头表示
           请求一个, 如p1有一条箭头指向r2表示p1请求一个r2资源, 每一个从资源指向进程的箭头表示当前
           资源已经分配给该进程的个数, 如r1有两个箭头指向p1则表示当前有两个r1资源分配给了进程p1

分析下图:
  对于r1资源来说, 其里面也有三个圆圈说明对于r1资源来说一共有三个, 从其出发有三条线, 说明对于这三个
  资源都已经分配出去了, 其中p1获得了两个, p2获得了一个, 对于r2资源来说, 有两个资源, 但是只分配出去
  了一个给p2, 此时p1请求一个r2资源, p2请求一个r1资源, 由于r1资源都已经被分配完成, 所以p2会进入阻塞
  状态, 而p1不会 

检验是否处于死锁状态:
  <1> 在资源分配图中, 找到一个既不阻塞又非独立的进程结点p, 如下图中中的p1节点, 其是不阻塞的, 并且
      其跟资源存在引用, 所以也不是独立的, 在顺利的情况下, p1可获得所需资源而继续执行, 直到运行完毕,
      再释放其所有资源, 此时就等于将其所有的请求边和分配边消去了, 使其成为了一个独立的节点
  <2> p1释放资源后, 便可使得p2获得资源而继续运行, 直到p2完成后又释放了它占有的所有资源, 同时消除其
      所有的分配边和请求边
  <3> 在进行一系列的简化之后, 若能消去图中所有的边, 使得所有的进程都成为孤立节点, 则称该图可完全简
      化的, 即不存在死锁, 而若通过任何过程使得该图完全简化, 则称该图是不可完全简化的, 即存在死锁

死锁定理: 当且仅当S状态的资源分配图是不可完全简化的
```

<img src="photos\01_死锁检测资源分配图.png" />

- 解除死锁
```
<1> 抢占资源, 从一个或多个进程中抢占足够数量的资源, 分配给死锁进程, 以解除死锁状态
<2> 终止(撤销)进程, 终止系统中的一个或者多个死锁进程, 直至打破循环环路, 使得系统从死锁状态解脱出来
```





















