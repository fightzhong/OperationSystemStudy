## 处理机调度的层次
```
高级调度: 又称长程调度或作业调度, 调度的对象是作业, 主要功能是根据某种算法, 决定将外存上处于后被队
         列中的哪几个作业调入内存, 为它们创建进程、分配必要的资源, 并将它们放入就绪队列, 主要用于
         多道批处理系统, 而在分时和实时系统中不设置高级调度, 该调度方式一般是从后备队列中选出几个
         作业, 将他们调入内存运行, 直到运行结束才调入下一批作业, 由于作业的运行时间一般较长, 所以
         叫长程调度
中级调度: 又称为内存调度, 在内存相对紧张的情况下, 会将一些不是很紧急的任务调出内存, 放置在外存的交
          换区中(即swap分区), 当内存充足时再将它们调回内存, 实际上就是内存管理中的对换功能
低级调度: 又称为进程调度或者短程调度, 其调度的对象是进程(或者内核级线程), 根据调度算法, 从就绪队列
         中选出一个进程并分配CPU资源给它, 在多道批处理系统、分时和实时系统的OS中都必须配备该级调度
```

## 调度算法的评判指标
```
CPU利用率 = 忙碌的时间 / 总时间
系统吞吐量 = 总共完成了多少道作业 / 总共花了多长时间   <即一段时间内完成的作业个数情况>
周转时间:
    周转时间 = 作业完成时间 - 作业提交时间
    平均周转时间 = 各作业周转时间之和 / 作业数
    带权周转时间 = 作业周转时间 / 作业实际运行时间
    平均带权周转时间 = 各作业带权周转时间之和 / 作业数
响应时间: 从用户提交请求到首次产生响应所用的时间    
```

## 进程调度的任务
```
<1> 保护处理机的现场信息, 在进行调度时必须将当前正在执行的线程的现场信息, 如程序计数器以及寄存器中
    的内容保存到当前线程的PCB中
<2> 按照特定的调度算法, 从就绪队列中选择一个进程, 将其状态改为运行状态, 并准备将处理机分配给它
<3> 把处理机(CPU)分配给进程, 将选中的进程的PCB中的相关信息装入处理器的寄存器中, 使得进程从上一次断
    点处开始执行
```

## 进程调度方式
```
一、非抢占式, 采用该方式调度时, 一旦把CPU分配给进程, 就一直让他运行下去, 绝不会因为时钟中断或者其
    他原因去抢占正在运行进程的CPU, 直到进程完成或者进程因发生了某个事件(如请求I/O)而被阻塞
二、抢占方式, 该方式允许CPU按照一定的规则去暂停当前正在运行的进程, 并将该CPU分配给其它进程, 抢占不
    是任意的行为, 必须遵守一定的规则, 主要有以下几种:
    <1> 优先权原则, 允许优先级高的新到的进程抢占当前进程的CPU
    <2> 短进程优先原始, 运行新到的短进程可以抢占当前正在执行的长进程的CPU资源
    <3> 时间片原则, 各个进程按照一定的时间片轮流运转, 当一个进程的CPU时间片用完后, 便暂停该进程的
        执行, 并执行进程调度

注意: 目前现代的OS主要采用抢占方式        
```
## 先来先服务算法(First-Come-First-Serve)
```
系统按照进程到达就绪队列的先后顺序来进行调度, 或者说它是优先考虑系统中等待时间最长的进程
```

## 短作业优先算法(Short-Job-First)
```
SJF算法以进程运行的长短来计算优先级, 运行时间越短则优先级越高, 系统在调度的时候会在就绪队列中选择运
行时间最短的进程进行CPU分配, 但是也存在一定的缺点：
  <1> 必须预知作业的运行时间, 然而即使是程序员也很难估算进程的运行时间
  <2> 对长进程不利, 如果有源源不断的短进程进入, 那么就有可能导致长进程饥饿的状况
  <3> 该调度算法完全未考虑进程的紧急程度, 所以一些紧急的任务不能得到优先的处理
```

## 轮转(round robin)调度算法
```
原理: 根据FCFS(first-come-first-serve)先来先服务原则, 将所有的进程按照顺序放入就绪队列, 并可以设
      置每隔一段时间就产生一次中断(如30ms), 激活系统中的调度程序, 完成一次调度, 将CPU分配给队首进
      程, 令其执行, 当该进程的时间片耗尽或者运行完毕后, 就继续执行调度程序将CPU分配给下一个队首进
      程, 这样就可以保证就绪队列中的所有进程在一定的时间段内都能获得一次CPU执行的权力    

进程切换的时机: 进程执行完毕或者进程所占用的时间片已经用完了, 其中这个时间片大小必须设置合理, 如果
                太短就会导致进程调度过于频繁, 无疑会增加系统的开销, 时间太长会导致许多进程能在一个
                时间片内完成任务, 进而退化成了FCFS算法
```

## 优先级调度算法
```
优先级的类型:
  - 静态优先级, 在进程被创建的时候就确定了一个进程的优先级, 缺点是优先级低的进程可能很长一段时间没
    有得到调度
  - 动态优先级, 在进程创建之初就赋予一个默认的优先级, 之后该优先级会随着运行的时间的增加而进行改变,
    例如可以规定进程在就绪队列中等待的时间越久则其优先级就增加, 而对于占用了CPU资源的进程, 其使用
    CPU的时间越久则其优先级越低这样即使在初始时进程的优先级低的情况下也能在等待一段时间后得到调度
```

## 多队列调度算法
```
描述: 我们上面所述的调度算法都是仅仅局限在一个就绪队列的, 这就导致了对于OS来说, 就绪队列进程调度的
      方式单一并且固定, 多队列调度算法将不同类型或性质的进程固定分配在不同的就绪队列, 不同的就绪队
      列采用不同的算法, 一个队列中的进程可以设置不同的优先级, 不同的就绪队列本身也可以设置不同的优
      先级, 这样在多CPU的情况下, 就很方便为每个CPU设置一个单独的就绪队列, 并执行不同的调度策略
```

## 多级反馈队列算法(目前公认的一种较好的进程调度算法)
```
调度机制:
  <1> 设置多个就绪队列, 在系统中设置多个就绪队列, 并为每一个队列赋予不同的优先级, 第一个队列的优先级
      最高, 第二个次之, 之后的依次降低
  <2> 每个队列都采用FCFS(先来先服务)算法, 当一个新的进程进入内存后, 首先将其放在第一队列的末尾, 按
      照FCFS原则以及时间片原则等待被调度, 如果该进程在时间片内没有执行完, 则将该进程放入下一个队列
      的末尾
  <3> 按照队列优先级调度, 调度程序首先调度优先级最高的队列, 只有当该队列中的进程都被调度完成后才去
      调度下一个队列, 也就是说要想当前队列被调度, 其前面的队列也必须被调度完成, 如果当前队列正在被
      调度时其高级的队列又有进程进入, 那么就必须转向高级的队列去调度进程
```