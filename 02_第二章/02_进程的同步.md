## 临界资源
```
如打印机, 磁带机等在同一时间只能运行一个进程访问的资源叫做临界资源
```

## 两种制约关系
```
<1> 间接相互制约关系, 多个程序在并发执行时, 由于共享资源如CPU, I/O设备等, 致使在这些并发执行的程
    序之间形成相互制约的关系
<2> 直接制约关系, 为了完成某任务而建立两个或者多个进程, 这些进程将为完成同一项任务而相互合作, 进程
    间的直接制约关系就是源于它们之间的相互合作
```

## 进程同步机制
```
该机制的主要任务是对多个相关进程在执行次序上进行协调, 使并发执行的诸进程之间能按照一定的规则共享系
统资源, 并能很好的相互合作, 从而使程序的执行具有可再现性
```

## 同步机制应该遵循的四大规则
```
<1> 忙则等待: 如果临界资源正在被访问, 则本进程必须等待, 以达到互斥访问
<2> 闲则让进: 如果临界资源没有被访问, 则允许本进程访问临界资源
<3> 有限等待: 应保证在有限时间内使得处于等待的进程能够访问临界资源
<4> 让权等待: 处于等待的线程应该放弃CPU资源, 直到可以访问临界资源时再重新尝试获取CPU资源
```

## 进程同步的机制
```
<1> 硬件机制: 关中断, 利用Test-and-Set指令或者Swap指令, 这三个共同的点就是在对锁进行测试的时候是
             一气呵成的, 不接收OS的中断信息以及CPU调度信息, 对于关中断的方式来说, 对多CPU的情况不
             适用, 因为在一个CPU上关闭中断并不能防止进程在其它CPU上被调度执行, 而其它两个通过指令
             的方式进行的同步也存在缺点, 因为它们会在临界资源忙碌时一直测试, 不符合让权等待原则
<2> 信号量机制, 也就是PV原子操作(执行时不可分割), 下面会基于信号量机制来实现三个进程同步问题的讲解
<3> 管程机制: 利用共享数据结构抽象地表示系统中的资源, 并将对该共享数据结构实施的特定操作定义为一组
             过程, 进程对共享资源的申请、释放和其它操作必须通过这组过程从而间接地对共享数据结构实
             现操作(确保只有一个进程进入管程去执行这组过程), 对于Java来说, 可以将将共享资源理解为
             类的私有成员变量(private static), 而对共享资源的一组过程可以理解为对该私有变量的操作
             的方法函数, 我们确保每次执行该方法时只有一个进程

下面将利用信号量机制即PV原子操作来解决三个进程同步问题
```

## 生产者消费者问题
- 问题描述
```
共享资源缓冲区中, 生产者生产产品并放入缓冲区, 消费者从缓冲区中取走产品, 当缓冲区满的时候, 生产者不
允许再向缓冲区中放入东西, 当缓冲区空的时候, 消费者不允许再从缓冲区中取走东西

分析: 
  <1> 生产者放产品进缓冲区和消费者从缓冲区中拿走产品这两个步骤必须是互斥的
  <2> 生产者放产品进缓冲区时需要判断缓冲区是否已经满了, 即是否还有位置
  <3> 消费者从缓冲区中拿走产品时需要先判断缓冲区中是否存在产品
```
- 信号量机制PV操作实现
```
emptyCount: 表示缓冲区中还有空闲位置的个数, 初始为10
eleCount: 表示缓冲区中还有元素的个数, 初始为0
c: 信号量, 初始值为1, 表示只允许一个进程进入该临界区

生产者                                      消费者
P(emptyCount)                            P(eleCount) 
P(c)                                     P(c)

临界区(生产者放入产品)                    临界区(消费者取走产品)        

V(c)                                     V(c)
V(eleCount)                              V(emptyCount)

分析:
  生产者在进入缓冲前需要判断是否还有空位放置产品, 如果没有则阻塞, 则当消费者进入缓冲区前判断是否缓
  冲区中存在产品, 如果有则判断锁c是否存在, 存在则获取该锁, 此时其它进程不能进入, 即被阻塞, 当消费
  者取走产品后归还该锁并将空位加一, 这样因为空位为0而阻塞的生产者才会被唤醒
```

## 苹果与橘子问题
- 问题描述
```
桌子上放置着一个盘子, 盘中中只能存放一个物品, 父亲和母亲可分别放入苹果和橘子, 儿子只允许拿苹果, 女
儿只允许拿橘子, 父亲只允许放苹果, 母亲只允许放橘子, 盘子为临界资源, 同一时间只能允许一个人访问
```

- 信号量机制PV操作实现
```
盘 = 1, 苹 = 0, 橘 = 0


父亲                  儿子                  母亲                  女儿
P(盘)                 P(苹)                 P(盘)                 P(橘)

放入苹果              取走苹果               放入橘子              取走橘子

V(苹)                 V(盘)                 V(橘)                 V(盘)
```

## 抽烟者问题
- 问题描述
```
一个系统中有三个抽烟者进程和一个供应者进程, 每个抽烟者按顺序从桌子上取烟, 供应者每次只能放一根烟到
桌子上, 桌子上只能放一根烟, 三个抽烟者分别抽不同的烟, 并且只能抽该烟, 只有当前拿到烟的抽烟者抽完了
才能告诉供应者继续放烟到桌子上 
```

- 信号量机制PV操作实现
```
供应者                抽烟者1                 抽烟者2                 抽烟者3
while(true){         P(烟1)                  P(烟2)                  P(烟3)
  P(finish)          

  if (i%3=0){        取烟1并抽之             取烟2并抽之              取烟3并抽之
    放烟1
    V(烟1)
  }
  if (i%3=1){       V(finish)               V(finish)               V(finish)
    放烟2
    V(烟2)
  }
  if (i%3=2){
    放烟3
    V(烟3)
  }
}
```

## 读者写者问题
- 问题描述
```
有读者和写者多个并发进程, 共享一个文件, 可以由多个读者进程对该文件进行读取, 但是此时写者进程不可访
问, 写者进程在操作文件时, 读者进程不可以访问, 只允许一个写者进程访问该文件
```

- 信号量机制PV操作实现
```
r: 读者的互斥操作, 利用P(r)和V(r)包裹的数据保证了在进入该区域时只能有一个读者进程, 初始为1
w: 读者-写者的互斥操作, 保证要么只有读者在对文件进行读取, 要么只有写者在写文件, 初始为1
count: 表示读者的数量, 初始为0

读者                                  写者
P(r)                                  P(w)
  if (count == 0){
    P(w)
  }
  count++;                           写文件       
V(r)

读取文件
                                     V(w)
P(r)                                  
  if (count == 1){
    v(w)
  }
  count--;
V(r)


分析:
  对于读者进程来说, 由于可以同时有多个读者进程访问文件, 但是读者进程和写者进程必须是互斥访问文件的,
  我们采取这样一种策略, 只有第一个读者进程才能获得写锁即w, 后面的读者进程就不用获取了, 而写者进程
  此时会因为w为0而被阻塞, 对于w已经被第一个读者获取后, 后面的读者因为count不是0, 则直接执行count++

弊端: 如果有源源不断的读者进程, 那么此时写者进程会出现饥饿的状态, 因为只有当读者进程只有一个并且该
      进程读取文件结束后才会唤醒写者进程  
```

- 解决方案(写者优先)
```
读者                                  写者
p(mutex)                              p(mutex)
P(r)                                  P(w)
  if (count == 0){
    P(w)
  }
  count++;                           写文件       
V(r)
v(mutex)            

读取文件
                                     V(w)
P(r)                                 v(mutex) 
  if (count == 1){
    v(w)
  }
  count--;
V(r)
```
