## 引入线程的原因
```
在OS中引入进程是为了使多个程序能够并发执行, 以提高资源利用率和系统吞吐量, 而OS引入线程, 是为了减少
程序在并发执行(进程调度)时所付出的时空开销(如进程阻塞时需要归还资源, 而调用进程时又需要重新拥有资
源, 总的来说, 进程间的切换开销比较大), 使OS具有更好的并发性
```

## 线程与进程的比较
```
<1> 在引入线程之前, 进程是资源分配和CPU调度的基本单位, 而引入线程之后, 进程仅仅成为了资源分配的基本
    单位, 线程成为了CPU调度的基本单位, 同一进程下的多个线程共享该进程的资源(OS分配的), 如OS分配的
    内存地址空间, 文件, 以及申请到的I/O设备等
<2> 在同一进程中, 线程的切换不会影响进程的切换, 但是从一个进程中的线程切换到另一个进程中的线程, 必
    然会引起进程的切换
<3> 系统开销, 创建或者撤销进程, OS都需要为之分配和回收进程控制块、分配或回收其他资源, 如内存空间和
    I/O设备, 而线程因为共享同一个进程的资源, 所以切换的代价较小
```

## 线程的的实现方式
- 内核支持线程(Kernel Supported Threads)
```
在OS中的所有进程, 其都是在OS内核的支持下运行的, 是与内核相关的, 而内核支持线程KST同样也是在内核的
支持下运行的, 它们的创建、阻塞、撤销和切换都是在内核空间完成的, 为了对内核线程进行控制和管理(就像
管理原始的进程一样), 在内核空间也为每一个内核线程设置了一个线程控制块, 内核根据该控制块而感知线程的
存在(跟进程一样), 并对其加以控制

优点:
  <1> 在多处理器系统中, 内核能够同时调度同一进程中的多个线程并行执行
  <2> 如果一个线程被阻塞了, 内核可以调用其它线程占用CPU, 也可以运行其它进程中的线程

缺点:
  对于用户的线程切换而已, 其模式切换的开销较大, 在同一个进程中, 线程的切换需要由用户态转为核心态进
  行, 这是因为用户进程的线程在用户态运行, 而线程调度和管理是在内核实现的, 系统开销较大  
```

- 用户级线程(User Level Threads)
```
描述: 用户级线程是在用户空间中实现的, 对线程的创建、撤销、同步与通信等功能, 都无需内核支持, 即用户
      级线程是与内核无关的, 内核也不知道用户级线程的存在, 所以线程的调度是基于该线程所在的进程为单
      位进行调度的, 也就是说即便在多CPU情况下, 该进程的所有线程也只能运行一个

优点:
  <1> 线程切换不需要切换到内核空间(与内核无关)
  <2> 调度算法可以是进程专用的, 即该进程可以根据需要自己选择不同的调度算法对进程中的线程进行管理
  <3> 用户级线程的实现与OS平台无关, 因为对于该线程管理的代码是属于用户程序的一部分, 用户级进程甚至
      可以在不支持线程机制的OS上实现

缺点:
  <1> 系统调用的阻塞问题, 用户级线程是基于其所在的进程为单位进行调度的, 一旦该进程中的某个线程进行
      阻塞(如系统调用), 则进程内的所有的线程都会进行阻塞(即不能获取CPU资源), 因为这就相当于进程阻塞
  <2> 用户级线程实现方式中, 多线程应用不能利用多处理机进行并行运行的优点, 内核每次分配给该进程的仅
      有一个CPU    
```

- 组合方式
```
一对一表示一个进程创建了多个内核级线程, 对于这些个内核级线程来说, 一个内核级线程又对应一个用户级线程,
多对一表示一个进程创建了多个内核级线程, 对于这些个内核级线程来说, 一个内核级线程又对应多个用户级线程,
多对多表示一个进程创建了多个内核级线程, 对于这些个内核级线程来说, 多个内核级线程又对应多个用户级线程
```

> Note: 现代的Java中JVM采用的是一对一的模型, 即创建一个Java线程其实可以理解为创建了一个用户级线程, 而该用户级线程又对应一个内核级线程

